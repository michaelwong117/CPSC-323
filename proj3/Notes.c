./323compiler path_to_testcase/testcase.c  
This will output on the console the IR generated after executing your optimization 
passes and creates a file called assembly.s which has your generated assembly code. 
You can execute your assembly in the following manner gcc testassembly/main.c assembly.s
 && ./a.outThis will output the answer generated after executing your assembly and throw 
 errors if any generated by your assembly code.

make testopt
make testcg
make all

for testing:

printprogram

make

./323compiler tests/example1.c 

you can make it and that will run it.


MUST DO: statements->node->right = CreateNumber(val); // create a node with this value
Node *expression = statements->node->right;
Does not work: expressions = CreateNumber(val)

1. Constant Folding (peephole optimization)

Expressions (KEY!!) where all operands are constants can 
be evaluated beforehand. 

valgrind --leak-check=full --show-leak-kinds=all ./323compiler tests/example1.c 

gcc -S testfile.c

gcc testassembly/main.c testfile.s 
./a.out

compare the output of gcc assembly with what gcc testassembly/main.c testfile.s

gcc testassembly/main.c yourgeneratedcode.s
./a.out

After you run ./323compiler tests/example.#c that will fprintf your assembly into the assembly.s file. 

if (arg->exprCode == CONSTANT) fprintf(fptr, "\nmovq %d, %%rdx", arg->value); 
else fprintf(fptr, "\nmovq %s, %%rdx", arg->name);

In order to check assembly output

Compare test.cg to gold.cg

You can also look to see how assembly.s differs from temp.s

RUN ake testcg to test example10.c


how to test manually

./323compiler usertests/userex0.c > dummy.ir;

gcc testassembly/main.c assembly.s -o test;
./test > test.cg

gcc -S usertests/userex0.c -o temp.s; 
gcc testassembly/main.c temp.s -o gold; 
./gold > gold.cg;



testcg: clean 323compiler
	@for i in $(shell ls ${TESTCASES}); do \
		./323compiler ${TESTCASES}/$${i} > dummy.ir; \
		gcc ${TESTASSEMBLY}/main.c assembly.s -o test; \
		./test > asm_output/test_$${i}.cg; \
		gcc -S ${TESTCASES}/$${i} -o asm_output/temp_$${i}.s; \
		gcc ${TESTASSEMBLY}/main.c asm_output/temp_$${i}.s -o gold; \
		./gold > gold.cg; \
		cmp -s test.cg gold.cg; \
		RETVALCG=$$?; \
		if [ $$RETVALCG -eq 0 ]; then\
			echo $${i} "CODEGEN PASS"; \
		else \
			echo $${i} "CODEGEN FAIL"; \
			return; \
		fi \
	done;	
	@rm dummy.ir
	@rm gold.cg
	@rm test.cg


void putRAXintoNewTemp(char * name)
{
    LongToCharOffset();
    AddVarInfo(name, lastOffsetUsed, INVAL, 0);

    fprintf(fptr, "\nmovq %%rax, %s", lastOffsetUsed);            
}